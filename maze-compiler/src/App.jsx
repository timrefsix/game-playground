import React, { useState } from 'react';
import {
  Play,
  Code,
  Cpu,
  FileCode,
  Settings,
  Sparkles,
  Binary,
  LayoutDashboard,
  ScrollText,
  Workflow,
} from 'lucide-react';

const MazeCompiler = () => {
  const [activeTab, setActiveTab] = useState('masm');
  const [masmCode, setMasmCode] = useState(`; Example MASM code with named data labels
.data
  forward_cmd "FORWARD"
  turn_left_cmd "TURN_LEFT"
  motor_port port_1
  loop_counter loop_counter

; Main program
LOAD_CONST @motor_port
LOAD_CONST @forward_cmd
CALL_METHOD

LOAD_CONST 5
STORE_VAR @loop_counter

:loop_start
LOAD_VAR @loop_counter
LOAD_CONST 0
GT
JUMPF :loop_end

LOAD_CONST @motor_port
LOAD_CONST @turn_left_cmd
CALL_METHOD

LOAD_VAR @loop_counter
LOAD_CONST 1
SUB
STORE_VAR @loop_counter
JUMP :loop_start

:loop_end
HALT`);
  
  const [mazeScript, setMazeScript] = useState(`-- Example MazeScript code
function movePattern(port, times)
  for i = 1, times do
    port.FORWARD()
    port.TURN_RIGHT()
  end
end

function main()
  movePattern(port_1, 5)
  
  if port_2.SENSOR() > 10 then
    port_1.BACKWARD()
  else
    port_1.FORWARD()
  end
end

main()`);

  const [modules, setModules] = useState([
    { port: 'port_1', type: 'Motor', commands: ['FORWARD', 'BACKWARD', 'TURN_LEFT', 'TURN_RIGHT', 'STOP'] },
    { port: 'port_2', type: 'Sensor', commands: ['SENSOR', 'READ', 'CALIBRATE'] },
  ]);

  const [bytecode, setBytecode] = useState([]);
  const [dataTable, setDataTable] = useState([]);
  const [dataLabels, setDataLabels] = useState({});
  const [compiledMasm, setCompiledMasm] = useState('');
  const [errors, setErrors] = useState([]);

  const tabs = [
    {
      id: 'masm',
      label: 'MASM Editor',
      description: 'Hand-craft Maze Assembly and inspect the generated bytecode.',
      icon: Code,
    },
    {
      id: 'mazescript',
      label: 'MazeScript',
      description: 'Author high-level scripts that transpile directly to MASM.',
      icon: FileCode,
    },
    {
      id: 'modules',
      label: 'Robot Modules',
      description: 'Review ports and capabilities exposed by your robot.',
      icon: Settings,
    },
  ];

  const compileStatus = errors.length
    ? {
        tone: 'error',
        label: 'Errors detected',
        description: 'Resolve the issues below to finish the build.',
      }
    : bytecode.length
      ? {
          tone: 'success',
          label: 'Build ready',
          description: 'Bytecode generated successfully â€“ export whenever you are ready.',
        }
      : {
          tone: 'neutral',
          label: 'Awaiting compilation',
          description: 'Write MazeScript or MASM to begin producing bytecode.',
        };

  const statCards = [
    {
      label: 'Data entries',
      value: dataTable.length,
      hint: 'Unique strings and numbers stored in the .data section.',
    },
    {
      label: 'Bytecode instructions',
      value: bytecode.length,
      hint: 'Total operations scheduled for the VM.',
    },
    {
      label: 'Configured modules',
      value: modules.length,
      hint: 'Ports exposed for MazeScript method calls.',
    },
  ];

  // Bytecode opcodes
  const OPCODES = {
    HALT: 0x00,
    LOAD_CONST: 0x01,
    LOAD_VAR: 0x02,
    STORE_VAR: 0x03,
    ADD: 0x10,
    SUB: 0x11,
    MUL: 0x12,
    DIV: 0x13,
    MOD: 0x14,
    EQ: 0x20,
    NEQ: 0x21,
    LT: 0x22,
    LTE: 0x23,
    GT: 0x24,
    GTE: 0x25,
    AND: 0x30,
    OR: 0x31,
    NOT: 0x32,
    JUMP: 0x40,
    JUMPT: 0x41,
    JUMPF: 0x42,
    CALL: 0x50,
    CALL_METHOD: 0x51,
    RETURN: 0x52,
    POP: 0x60,
    DUP: 0x61,
    SWAP: 0x62,
    LOAD_INDEX: 0x70,
    STORE_INDEX: 0x71,
    NEW_LIST: 0x72,
    NEW_OBJECT: 0x73,
    GET_FIELD: 0x74,
    SET_FIELD: 0x75,
  };

  // Compile MASM to bytecode
  const compileMASM = (code) => {
    const lines = code.split('\n').map(l => l.trim()).filter(l => l && !l.startsWith(';'));
    const bytecode = [];
    const dataTable = [];
    const dataLabels = {}; // Map label names to indices
    const labels = {};
    const errors = [];
    let address = 0;
    let inDataSection = false;

    // First pass: collect data section and labels
    lines.forEach((line) => {
      if (line === '.data') {
        inDataSection = true;
        return;
      }
      
      if (line.startsWith('.')) {
        inDataSection = false;
        return;
      }

      if (inDataSection) {
        // Parse data directive: label value OR @index value
        // Support formats:
        // forward_cmd "FORWARD"
        // @0 "FORWARD"
        // port_motor port_1
        const match = line.match(/^(@?\w+)\s+(.+)$/);
        if (match) {
          const label = match[1];
          let value = match[2].trim();

          // Remove quotes if present
          if ((value.startsWith('"') && value.endsWith('"')) ||
              (value.startsWith("'") && value.endsWith("'"))) {
            value = value.slice(1, -1);
          }

          // Parse numbers
          if (!isNaN(value)) {
            value = parseFloat(value);
          }

          // Check if label is @index format
          if (label.startsWith('@')) {
            const index = parseInt(label.slice(1));
            dataTable[index] = value;
            dataLabels[label] = index;
          } else {
            // Named label - add to next available index
            const index = dataTable.length;
            dataTable.push(value);
            dataLabels[label] = index;
          }

          return;
        }

        // A non-matching line signals the start of the code section.
        inDataSection = false;
      }

      if (line.startsWith(':')) {
        labels[line] = address;
      } else {
        const parts = line.split(/\s+/);
        const opcode = parts[0];
        
        if (OPCODES[opcode] !== undefined) {
          address += 1;
          if (parts.length > 1) {
            address += 1; // For operand
          }
        }
      }
    });

    // Second pass: generate bytecode
    address = 0;
    inDataSection = false;
    
    lines.forEach((line, lineNum) => {
      if (line === '.data') {
        inDataSection = true;
        return;
      }
      
      if (line.startsWith('.')) {
        inDataSection = false;
        return;
      }

    if (inDataSection) {
      const match = line.match(/^(@?\w+)\s+(.+)$/);
      if (match) {
        return;
      }
      inDataSection = false;
    }

    if (line.startsWith(':')) return;

      const parts = line.split(/\s+/);
      const opcode = parts[0];
      const operand = parts.slice(1).join(' ');

      if (OPCODES[opcode] === undefined) {
        errors.push(`Line ${lineNum + 1}: Unknown opcode '${opcode}'`);
        return;
      }

      bytecode.push({ type: 'opcode', value: OPCODES[opcode], mnemonic: opcode, address });
      address++;

      if (operand) {
        let operandValue;
        
        if (operand.startsWith(':')) {
          // Label reference
          if (labels[operand] === undefined) {
            errors.push(`Line ${lineNum + 1}: Undefined label '${operand}'`);
            operandValue = 0;
          } else {
            operandValue = labels[operand];
          }
        } else if (operand.startsWith('@')) {
          // Data table reference - could be @index or @label
          const dataRef = operand.slice(1);
          let dataIndex;
          
          // Check if it's a numeric index
          if (!isNaN(dataRef)) {
            dataIndex = parseInt(dataRef);
          } else {
            // It's a named label
            dataIndex = dataLabels[dataRef];
          }
          
          if (dataIndex === undefined || dataTable[dataIndex] === undefined) {
            errors.push(`Line ${lineNum + 1}: Undefined data reference '${operand}'`);
            operandValue = 0;
          } else {
            operandValue = dataIndex; // Store the numeric index
          }
        } else if (!isNaN(operand)) {
          // Numeric literal
          operandValue = parseFloat(operand);
        } else {
          // Variable name or identifier - auto-add to data table
          let dataIndex = dataTable.indexOf(operand);
          if (dataIndex === -1) {
            dataIndex = dataTable.length;
            dataTable.push(operand);
          }
          operandValue = dataIndex; // Store the numeric index
        }

        bytecode.push({ type: 'operand', value: operandValue, address });
        address++;
      }
    });

    return { bytecode, dataTable, dataLabels, errors };
  };

  // Compile MazeScript to MASM
  const compileMazeScriptToMASM = (code) => {
    const errors = [];
    const masm = [];
    const dataTable = [];
    let tempCounter = 0;
    let labelCounter = 0;
    const symbolTable = { vars: new Map(), functions: new Map() };

    const newTemp = () => `_temp${tempCounter++}`;
    const newLabel = (prefix) => `:_${prefix}_${labelCounter++}`;
    
    // Get or create data table entry - returns numeric index
    const getDataIndex = (value) => {
      let index = dataTable.indexOf(value);
      if (index === -1) {
        index = dataTable.length;
        dataTable.push(value);
      }
      return index;
    };

    // Tokenizer
    const tokenize = (code) => {
      const tokens = [];
      let i = 0;
      
      while (i < code.length) {
        // Skip whitespace
        if (/\s/.test(code[i])) {
          i++;
          continue;
        }

        // Skip comments
        if (code.substring(i, i + 2) === '--') {
          while (i < code.length && code[i] !== '\n') i++;
          continue;
        }

        // String literals
        if (code[i] === '"' || code[i] === "'") {
          const quote = code[i];
          let str = '';
          i++;
          while (i < code.length && code[i] !== quote) {
            if (code[i] === '\\') {
              i++;
              str += code[i];
            } else {
              str += code[i];
            }
            i++;
          }
          i++;
          tokens.push({ type: 'string', value: str });
          continue;
        }

        // Numbers
        if (/[0-9]/.test(code[i])) {
          let num = '';
          while (i < code.length && /[0-9.]/.test(code[i])) {
            num += code[i++];
          }
          tokens.push({ type: 'number', value: parseFloat(num) });
          continue;
        }

        // Identifiers and keywords
        if (/[a-zA-Z_]/.test(code[i])) {
          let id = '';
          while (i < code.length && /[a-zA-Z0-9_]/.test(code[i])) {
            id += code[i++];
          }
          const keywords = ['function', 'end', 'if', 'then', 'else', 'elseif', 'for', 'do', 'while', 'return', 'local', 'and', 'or', 'not'];
          tokens.push({ type: keywords.includes(id) ? 'keyword' : 'identifier', value: id });
          continue;
        }

        // Operators and punctuation
        const twoCharOps = ['==', '~=', '<=', '>=', '..'];
        const twoChar = code.substring(i, i + 2);
        if (twoCharOps.includes(twoChar)) {
          tokens.push({ type: 'operator', value: twoChar });
          i += 2;
          continue;
        }

        tokens.push({ type: 'operator', value: code[i] });
        i++;
      }

      return tokens;
    };

    // Parser
    class Parser {
      constructor(tokens) {
        this.tokens = tokens;
        this.pos = 0;
      }

      current() {
        return this.tokens[this.pos];
      }

      peek(offset = 1) {
        return this.tokens[this.pos + offset];
      }

      advance() {
        return this.tokens[this.pos++];
      }

      expect(type, value = null) {
        const token = this.current();
        if (!token || token.type !== type || (value !== null && token.value !== value)) {
          throw new Error(`Expected ${type}${value ? ` '${value}'` : ''}, got ${token ? token.value : 'EOF'}`);
        }
        return this.advance();
      }

      parse() {
        const statements = [];
        while (this.current()) {
          statements.push(this.parseStatement());
        }
        return statements;
      }

      parseStatement() {
        const token = this.current();
        
        if (!token) return null;

        if (token.type === 'keyword') {
          switch (token.value) {
            case 'function': return this.parseFunction();
            case 'if': return this.parseIf();
            case 'for': return this.parseFor();
            case 'while': return this.parseWhile();
            case 'return': return this.parseReturn();
            case 'local': return this.parseLocal();
          }
        }

        // Assignment or expression statement
        if (token.type === 'identifier') {
          const next = this.peek();
          if (next && next.type === 'operator' && next.value === '=') {
            return this.parseAssignment();
          }
        }

        return this.parseExpressionStatement();
      }

      parseFunction() {
        this.expect('keyword', 'function');
        const name = this.expect('identifier').value;
        this.expect('operator', '(');
        
        const params = [];
        if (this.current() && this.current().value !== ')') {
          params.push(this.expect('identifier').value);
          while (this.current() && this.current().value === ',') {
            this.advance();
            params.push(this.expect('identifier').value);
          }
        }
        
        this.expect('operator', ')');
        
        const body = [];
        while (this.current() && !(this.current().type === 'keyword' && this.current().value === 'end')) {
          body.push(this.parseStatement());
        }
        
        this.expect('keyword', 'end');
        
        return { type: 'function', name, params, body };
      }

      parseIf() {
        this.expect('keyword', 'if');
        const condition = this.parseExpression();
        this.expect('keyword', 'then');
        
        const thenBody = [];
        while (this.current() && !(this.current().type === 'keyword' && ['else', 'elseif', 'end'].includes(this.current().value))) {
          thenBody.push(this.parseStatement());
        }
        
        let elseBody = [];
        if (this.current() && this.current().value === 'else') {
          this.advance();
          while (this.current() && !(this.current().type === 'keyword' && this.current().value === 'end')) {
            elseBody.push(this.parseStatement());
          }
        }
        
        this.expect('keyword', 'end');
        
        return { type: 'if', condition, thenBody, elseBody };
      }

      parseFor() {
        this.expect('keyword', 'for');
        const variable = this.expect('identifier').value;
        this.expect('operator', '=');
        const start = this.parseExpression();
        this.expect('operator', ',');
        const end = this.parseExpression();
        
        let step = { type: 'literal', value: 1 };
        if (this.current() && this.current().value === ',') {
          this.advance();
          step = this.parseExpression();
        }
        
        this.expect('keyword', 'do');
        
        const body = [];
        while (this.current() && !(this.current().type === 'keyword' && this.current().value === 'end')) {
          body.push(this.parseStatement());
        }
        
        this.expect('keyword', 'end');
        
        return { type: 'for', variable, start, end, step, body };
      }

      parseWhile() {
        this.expect('keyword', 'while');
        const condition = this.parseExpression();
        this.expect('keyword', 'do');
        
        const body = [];
        while (this.current() && !(this.current().type === 'keyword' && this.current().value === 'end')) {
          body.push(this.parseStatement());
        }
        
        this.expect('keyword', 'end');
        
        return { type: 'while', condition, body };
      }

      parseReturn() {
        this.expect('keyword', 'return');
        const value = this.current() && this.current().type !== 'keyword' ? this.parseExpression() : null;
        return { type: 'return', value };
      }

      parseLocal() {
        this.expect('keyword', 'local');
        const name = this.expect('identifier').value;
        let value = null;
        if (this.current() && this.current().value === '=') {
          this.advance();
          value = this.parseExpression();
        }
        return { type: 'local', name, value };
      }

      parseAssignment() {
        const target = this.parseExpression();
        this.expect('operator', '=');
        const value = this.parseExpression();
        return { type: 'assignment', target, value };
      }

      parseExpressionStatement() {
        const expr = this.parseExpression();
        return { type: 'expressionStatement', expression: expr };
      }

      parseExpression() {
        return this.parseOr();
      }

      parseOr() {
        let left = this.parseAnd();
        
        while (this.current() && this.current().type === 'keyword' && this.current().value === 'or') {
          this.advance();
          const right = this.parseAnd();
          left = { type: 'binary', operator: 'or', left, right };
        }
        
        return left;
      }

      parseAnd() {
        let left = this.parseComparison();
        
        while (this.current() && this.current().type === 'keyword' && this.current().value === 'and') {
          this.advance();
          const right = this.parseComparison();
          left = { type: 'binary', operator: 'and', left, right };
        }
        
        return left;
      }

      parseComparison() {
        let left = this.parseAdditive();
        
        while (this.current() && this.current().type === 'operator' && ['==', '~=', '<', '<=', '>', '>='].includes(this.current().value)) {
          const op = this.advance().value;
          const right = this.parseAdditive();
          left = { type: 'binary', operator: op, left, right };
        }
        
        return left;
      }

      parseAdditive() {
        let left = this.parseMultiplicative();
        
        while (this.current() && this.current().type === 'operator' && ['+', '-'].includes(this.current().value)) {
          const op = this.advance().value;
          const right = this.parseMultiplicative();
          left = { type: 'binary', operator: op, left, right };
        }
        
        return left;
      }

      parseMultiplicative() {
        let left = this.parseUnary();
        
        while (this.current() && this.current().type === 'operator' && ['*', '/', '%'].includes(this.current().value)) {
          const op = this.advance().value;
          const right = this.parseUnary();
          left = { type: 'binary', operator: op, left, right };
        }
        
        return left;
      }

      parseUnary() {
        if (this.current() && this.current().type === 'keyword' && this.current().value === 'not') {
          this.advance();
          return { type: 'unary', operator: 'not', operand: this.parseUnary() };
        }
        
        if (this.current() && this.current().type === 'operator' && this.current().value === '-') {
          this.advance();
          return { type: 'unary', operator: '-', operand: this.parseUnary() };
        }
        
        return this.parsePostfix();
      }

      parsePostfix() {
        let expr = this.parsePrimary();
        
        while (this.current()) {
          if (this.current().type === 'operator' && this.current().value === '(') {
            // Function call
            this.advance();
            const args = [];
            if (this.current() && this.current().value !== ')') {
              args.push(this.parseExpression());
              while (this.current() && this.current().value === ',') {
                this.advance();
                args.push(this.parseExpression());
              }
            }
            this.expect('operator', ')');
            expr = { type: 'call', callee: expr, args };
          } else if (this.current().type === 'operator' && this.current().value === '.') {
            // Field access or method call
            this.advance();
            const field = this.expect('identifier').value;
            
            if (this.current() && this.current().value === '(') {
              // Method call
              this.advance();
              const args = [];
              if (this.current() && this.current().value !== ')') {
                args.push(this.parseExpression());
                while (this.current() && this.current().value === ',') {
                  this.advance();
                  args.push(this.parseExpression());
                }
              }
              this.expect('operator', ')');
              expr = { type: 'methodCall', object: expr, method: field, args };
            } else {
              // Field access
              expr = { type: 'fieldAccess', object: expr, field };
            }
          } else if (this.current().type === 'operator' && this.current().value === '[') {
            // Index access
            this.advance();
            const index = this.parseExpression();
            this.expect('operator', ']');
            expr = { type: 'indexAccess', object: expr, index };
          } else {
            break;
          }
        }
        
        return expr;
      }

      parsePrimary() {
        const token = this.current();
        
        if (!token) {
          throw new Error('Unexpected end of input');
        }
        
        if (token.type === 'number') {
          this.advance();
          return { type: 'literal', value: token.value };
        }
        
        if (token.type === 'string') {
          this.advance();
          return { type: 'literal', value: token.value };
        }
        
        if (token.type === 'identifier') {
          this.advance();
          return { type: 'identifier', name: token.value };
        }
        
        if (token.type === 'operator' && token.value === '(') {
          this.advance();
          const expr = this.parseExpression();
          this.expect('operator', ')');
          return expr;
        }
        
        if (token.type === 'operator' && token.value === '{') {
          // Table/Object literal
          this.advance();
          const entries = [];
          
          while (this.current() && this.current().value !== '}') {
            if (this.current().type === 'identifier' && this.peek() && this.peek().value === '=') {
              const key = this.advance().value;
              this.expect('operator', '=');
              const value = this.parseExpression();
              entries.push({ key, value });
            } else {
              const value = this.parseExpression();
              entries.push({ key: null, value });
            }
            
            if (this.current() && this.current().value === ',') {
              this.advance();
            }
          }
          
          this.expect('operator', '}');
          return { type: 'object', entries };
        }
        
        throw new Error(`Unexpected token: ${token.value}`);
      }
    }

    // Code generator
    const generate = (ast) => {
      const varCounter = { count: 0 };

      // Generate .data section at the beginning
      const generateDataSection = () => {
        if (dataTable.length > 0) {
          masm.push('; Data section');
          masm.push('.data');
          dataTable.forEach((value, index) => {
            if (typeof value === 'string') {
              masm.push(`  @${index} "${value}"`);
            } else {
              masm.push(`  @${index} ${value}`);
            }
          });
          masm.push('');
        }
      };

      const generateStatement = (stmt) => {
        if (!stmt) return;

        switch (stmt.type) {
          case 'function':
            const funcLabel = `:func_${stmt.name}`;
            symbolTable.functions.set(stmt.name, { label: funcLabel, params: stmt.params });
            masm.push(`; Function: ${stmt.name}`);
            masm.push(funcLabel);
            
            // Setup parameters
            stmt.params.reverse().forEach(param => {
              const paramIndex = getDataIndex(param);
              symbolTable.vars.set(param, paramIndex);
              masm.push(`STORE_VAR @${paramIndex}`);
            });
            
            // Generate body
            stmt.body.forEach(s => generateStatement(s));
            
            // Implicit return
            if (!stmt.body.length || stmt.body[stmt.body.length - 1].type !== 'return') {
              masm.push(`LOAD_CONST 0`);
              masm.push(`RETURN`);
            }
            break;

          case 'if':
            const elseLabel = newLabel('else');
            const endLabel = newLabel('endif');
            
            generateExpression(stmt.condition);
            masm.push(`JUMPF ${stmt.elseBody.length ? elseLabel : endLabel}`);
            
            stmt.thenBody.forEach(s => generateStatement(s));
            if (stmt.elseBody.length) {
              masm.push(`JUMP ${endLabel}`);
              masm.push(elseLabel);
              stmt.elseBody.forEach(s => generateStatement(s));
            }
            
            masm.push(endLabel);
            break;

          case 'for':
            const loopStart = newLabel('for_start');
            const loopEnd = newLabel('for_end');
            
            // Initialize loop variable
            const varIndex = getDataIndex(stmt.variable);
            generateExpression(stmt.start);
            symbolTable.vars.set(stmt.variable, varIndex);
            masm.push(`STORE_VAR @${varIndex}`);
            
            masm.push(loopStart);
            
            // Check condition
            masm.push(`LOAD_VAR @${varIndex}`);
            generateExpression(stmt.end);
            masm.push(`LTE`);
            masm.push(`JUMPF ${loopEnd}`);
            
            // Body
            stmt.body.forEach(s => generateStatement(s));
            
            // Increment
            masm.push(`LOAD_VAR @${varIndex}`);
            generateExpression(stmt.step);
            masm.push(`ADD`);
            masm.push(`STORE_VAR @${varIndex}`);
            
            masm.push(`JUMP ${loopStart}`);
            masm.push(loopEnd);
            break;

          case 'while':
            const whileStart = newLabel('while_start');
            const whileEnd = newLabel('while_end');
            
            masm.push(whileStart);
            generateExpression(stmt.condition);
            masm.push(`JUMPF ${whileEnd}`);
            
            stmt.body.forEach(s => generateStatement(s));
            
            masm.push(`JUMP ${whileStart}`);
            masm.push(whileEnd);
            break;

          case 'return':
            if (stmt.value) {
              generateExpression(stmt.value);
            } else {
              masm.push(`LOAD_CONST 0`);
            }
            masm.push(`RETURN`);
            break;

          case 'local':
            const localIndex = getDataIndex(stmt.name);
            if (stmt.value) {
              generateExpression(stmt.value);
            } else {
              masm.push(`LOAD_CONST 0`);
            }
            symbolTable.vars.set(stmt.name, localIndex);
            masm.push(`STORE_VAR @${localIndex}`);
            break;

          case 'assignment':
            generateExpression(stmt.value);
            if (stmt.target.type === 'identifier') {
              let targetIndex = symbolTable.vars.get(stmt.target.name);
              if (targetIndex === undefined) {
                targetIndex = getDataIndex(stmt.target.name);
                symbolTable.vars.set(stmt.target.name, targetIndex);
              }
              masm.push(`STORE_VAR @${targetIndex}`);
            } else if (stmt.target.type === 'indexAccess') {
              generateExpression(stmt.target.object);
              generateExpression(stmt.target.index);
              masm.push(`STORE_INDEX`);
            } else if (stmt.target.type === 'fieldAccess') {
              generateExpression(stmt.target.object);
              masm.push(`LOAD_CONST @${getDataIndex(stmt.target.field)}`);
              masm.push(`SET_FIELD`);
            }
            break;

          case 'expressionStatement':
            generateExpression(stmt.expression);
            masm.push(`POP`); // Discard result
            break;
        }
      };

      const generateExpression = (expr) => {
        switch (expr.type) {
          case 'literal':
            if (typeof expr.value === 'string') {
              masm.push(`LOAD_CONST @${getDataIndex(expr.value)}`);
            } else {
              masm.push(`LOAD_CONST ${expr.value}`);
            }
            break;

          case 'identifier':
            let varIndex = symbolTable.vars.get(expr.name);
            if (varIndex === undefined) {
              varIndex = getDataIndex(expr.name);
              symbolTable.vars.set(expr.name, varIndex);
            }
            masm.push(`LOAD_VAR @${varIndex}`);
            break;

          case 'binary':
            generateExpression(expr.left);
            generateExpression(expr.right);
            
            const opMap = {
              '+': 'ADD', '-': 'SUB', '*': 'MUL', '/': 'DIV', '%': 'MOD',
              '==': 'EQ', '~=': 'NEQ', '<': 'LT', '<=': 'LTE', '>': 'GT', '>=': 'GTE',
              'and': 'AND', 'or': 'OR'
            };
            
            masm.push(opMap[expr.operator] || 'ADD');
            break;

          case 'unary':
            generateExpression(expr.operand);
            if (expr.operator === 'not') {
              masm.push('NOT');
            } else if (expr.operator === '-') {
              masm.push('LOAD_CONST -1');
              masm.push('MUL');
            }
            break;

          case 'call':
            // Push arguments
            expr.args.forEach(arg => generateExpression(arg));
            
            if (expr.callee.type === 'identifier') {
              const funcInfo = symbolTable.functions.get(expr.callee.name);
              if (funcInfo) {
                masm.push(`CALL ${funcInfo.label}`);
              } else {
                let funcIndex = symbolTable.vars.get(expr.callee.name);
                if (funcIndex === undefined) {
                  funcIndex = getDataIndex(expr.callee.name);
                }
                masm.push(`LOAD_VAR @${funcIndex}`);
                masm.push(`CALL`);
              }
            } else {
              generateExpression(expr.callee);
              masm.push(`CALL`);
            }
            break;

          case 'methodCall':
            // Load object (port)
            generateExpression(expr.object);
            // Load method name
            masm.push(`LOAD_CONST @${getDataIndex(expr.method)}`);
            // Push arguments if any
            expr.args.forEach(arg => generateExpression(arg));
            // Call method
            masm.push(`CALL_METHOD`);
            break;

          case 'fieldAccess':
            generateExpression(expr.object);
            masm.push(`LOAD_CONST @${getDataIndex(expr.field)}`);
            masm.push(`GET_FIELD`);
            break;

          case 'indexAccess':
            generateExpression(expr.object);
            generateExpression(expr.index);
            masm.push(`LOAD_INDEX`);
            break;

          case 'object':
            masm.push(`NEW_OBJECT`);
            expr.entries.forEach((entry, idx) => {
              masm.push(`DUP`); // Duplicate object reference
              if (entry.key) {
                masm.push(`LOAD_CONST @${getDataIndex(entry.key)}`);
              } else {
                masm.push(`LOAD_CONST ${idx + 1}`); // Lua arrays are 1-indexed
              }
              generateExpression(entry.value);
              masm.push(`SET_FIELD`);
            });
            break;
        }
      };

      try {
        ast.forEach(stmt => generateStatement(stmt));
        masm.unshift(''); // Add blank line before data section
        generateDataSection();
        masm.push('HALT');
      } catch (e) {
        errors.push(`Code generation error: ${e.message}`);
      }
    };

    try {
      const tokens = tokenize(code);
      const parser = new Parser(tokens);
      const ast = parser.parse();
      generate(ast);
    } catch (e) {
      errors.push(`Parse error: ${e.message}`);
    }

    return { masm: masm.join('\n'), errors };
  };

  const handleCompileMASM = () => {
    const result = compileMASM(masmCode);
    setBytecode(result.bytecode);
    setDataTable(result.dataTable);
    setDataLabels(result.dataLabels || {});
    setErrors(result.errors);
  };

  const handleCompileMazeScript = () => {
    const result = compileMazeScriptToMASM(mazeScript);
    setCompiledMasm(result.masm);
    setErrors(result.errors);
    
    if (result.errors.length === 0) {
      const bytecodeResult = compileMASM(result.masm);
      setBytecode(bytecodeResult.bytecode);
      setDataTable(bytecodeResult.dataTable);
      setDataLabels(bytecodeResult.dataLabels || {});
      setErrors([...result.errors, ...bytecodeResult.errors]);
    }
  };

  const formatBytecode = () => {
    const output = [];
    
    // Data section header
    if (dataTable.length > 0) {
      output.push('; ==================== DATA SECTION ====================');
      output.push('; Magic: MAZE');
      output.push('; Version: 1.0');
      output.push(`; Data entries: ${dataTable.length}`);
      output.push('');
      
      dataTable.forEach((entry, idx) => {
        // Find label name for this index
        const labelName = Object.keys(dataLabels).find(
          label => dataLabels[label] === idx && !label.startsWith('@')
        );
        
        const typeMarker = typeof entry === 'string' ? '0x01' : '0x02';
        const labelStr = labelName ? ` (${labelName})` : '';
        
        if (typeof entry === 'string') {
          const hexBytes = Array.from(entry).map(c => 
            '0x' + c.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase()
          ).join(' ');
          output.push(`DATA ${idx.toString().padStart(4, '0')}${labelStr}: ${typeMarker} [string, len=${entry.length}]`);
          output.push(`           "${entry}"`);
          output.push(`           ${hexBytes}`);
        } else {
          const view = new DataView(new ArrayBuffer(8));
          view.setFloat64(0, entry, true);
          const hexBytes = Array.from(new Uint8Array(view.buffer))
            .map(b => '0x' + b.toString(16).padStart(2, '0').toUpperCase())
            .join(' ');
          output.push(`DATA ${idx.toString().padStart(4, '0')}${labelStr}: ${typeMarker} [number]`);
          output.push(`           ${entry}`);
          output.push(`           ${hexBytes}`);
        }
        output.push('');
      });
    }
    
    // Code section header
    output.push('; ==================== CODE SECTION ====================');
    output.push(`; Instructions: ${bytecode.length}`);
    output.push('');
    
    // Bytecode instructions
    bytecode.forEach((instr, idx) => {
      if (instr.type === 'opcode') {
        const hex = instr.value.toString(16).padStart(2, '0').toUpperCase();
        output.push(`${instr.address.toString().padStart(4, '0')}: 0x${hex}  ${instr.mnemonic}`);
      } else {
        let value = instr.value;
        output.push(`${instr.address.toString().padStart(4, '0')}:        ${value}`);
      }
    });
    
    return output.join('\n');
  };

  const exportBinary = () => {
    const buffer = [];
    
    // Magic number "MAZE"
    buffer.push(0x4D, 0x41, 0x5A, 0x45);
    
    // Version
    buffer.push(0x01, 0x00);
    
    // Data table size (2 bytes)
    const dataSize = dataTable.length;
    buffer.push((dataSize >> 8) & 0xFF, dataSize & 0xFF);
    
    // Data table
    dataTable.forEach(entry => {
      if (typeof entry === 'string') {
        // String type marker
        buffer.push(0x01);
        // String length (2 bytes)
        const len = entry.length;
        buffer.push((len >> 8) & 0xFF, len & 0xFF);
        // String bytes (UTF-8)
        for (let i = 0; i < entry.length; i++) {
          buffer.push(entry.charCodeAt(i) & 0xFF);
        }
      } else if (typeof entry === 'number') {
        // Number type marker
        buffer.push(0x02);
        // 8-byte double (simplified: using 4-byte float representation)
        const view = new DataView(new ArrayBuffer(8));
        view.setFloat64(0, entry, true);
        for (let i = 0; i < 8; i++) {
          buffer.push(view.getUint8(i));
        }
      }
    });
    
    // Code size (4 bytes)
    const codeSize = bytecode.length;
    buffer.push(
      (codeSize >> 24) & 0xFF,
      (codeSize >> 16) & 0xFF,
      (codeSize >> 8) & 0xFF,
      codeSize & 0xFF
    );
    
    // Bytecode
    bytecode.forEach(instr => {
      if (instr.type === 'opcode') {
        buffer.push(instr.value);
      } else {
        const value = instr.value;
        if (typeof value === 'number') {
          // For data references or inline numbers, use 8 bytes
          const view = new DataView(new ArrayBuffer(8));
          view.setFloat64(0, value, true);
          for (let i = 0; i < 8; i++) {
            buffer.push(view.getUint8(i));
          }
        } else {
          // Fallback: 0
          buffer.push(0, 0, 0, 0, 0, 0, 0, 0);
        }
      }
    });
    
    // Create blob and download
    const blob = new Blob([new Uint8Array(buffer)], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'program.mzb';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  return (
    <div className="app-shell">
      <header className="hero">
        <div className="hero__glow" />
        <div className="hero__content">
          <div className="hero__eyebrow">
            <Sparkles className="hero__icon" aria-hidden="true" />
            Maze Robotics Toolkit
          </div>
          <h1>Maze Compiler Studio</h1>
          <p>
            Write MazeScript, convert to MASM, and inspect bytecode from a single polished workbench.
          </p>
          <div className="hero__meta">
            <div className="hero__meta-card">
              <Binary className="hero__meta-icon" aria-hidden="true" />
              Dual-language pipeline
            </div>
            <div className="hero__meta-card">
              <Workflow className="hero__meta-icon" aria-hidden="true" />
              Robot-ready bytecode export
            </div>
          </div>
        </div>
      </header>

      <main className="main-layout">
        <section className="workspace glass-panel">
          <div className="workspace__header">
            <div className="workspace__title">
              <Cpu className="workspace__icon" aria-hidden="true" />
              <div>
                <h2>Compilation Workbench</h2>
                <p>Switch between editors, generate MASM, and export Maze bytecode without leaving the page.</p>
              </div>
            </div>
            <div className={`status-pill status-pill--${compileStatus.tone}`} data-testid="compile-status">
              <span>{compileStatus.label}</span>
            </div>
          </div>
          <p className="workspace__description">{compileStatus.description}</p>

          <div className="tab-strip" role="tablist">
            {tabs.map((tab) => {
              const TabIcon = tab.icon;
              const isActive = activeTab === tab.id;
              const tabId = `tab-${tab.id}`;
              const panelId = `panel-${tab.id}`;
              return (
                <button
                  key={tab.id}
                  id={tabId}
                  type="button"
                  onClick={() => setActiveTab(tab.id)}
                  className={`tab-button${isActive ? ' is-active' : ''}`}
                  role="tab"
                  aria-selected={isActive}
                  aria-controls={panelId}
                  tabIndex={isActive ? 0 : -1}
                >
                  <TabIcon className="tab-button__icon" aria-hidden="true" />
                  <div className="tab-button__meta">
                    <span className="tab-button__title">{tab.label}</span>
                    <span className="tab-button__hint">{tab.description}</span>
                  </div>
                </button>
              );
            })}
          </div>

          <div className="tab-panels">
            {activeTab === 'masm' && (
              <div className="panel-block" role="tabpanel" id="panel-masm" aria-labelledby="tab-masm">
                <label className="field-label" htmlFor="masm-editor">
                  MASM Code
                </label>
                <textarea
                  id="masm-editor"
                  value={masmCode}
                  onChange={(e) => setMasmCode(e.target.value)}
                  className="code-area code-area--masm"
                  placeholder="Enter MASM code..."
                />
                <button
                  type="button"
                  onClick={handleCompileMASM}
                  className="primary-button"
                >
                  <Play className="primary-button__icon" aria-hidden="true" />
                  Compile to Bytecode
                </button>
              </div>
            )}

            {activeTab === 'mazescript' && (
              <div className="panel-block" role="tabpanel" id="panel-mazescript" aria-labelledby="tab-mazescript">
                <label className="field-label" htmlFor="maze-editor">
                  MazeScript Code
                </label>
                <textarea
                  id="maze-editor"
                  value={mazeScript}
                  onChange={(e) => setMazeScript(e.target.value)}
                  className="code-area code-area--maze"
                  placeholder="Enter MazeScript code..."
                />
                <button
                  type="button"
                  onClick={handleCompileMazeScript}
                  className="primary-button"
                >
                  <Play className="primary-button__icon" aria-hidden="true" />
                  Compile to MASM &amp; Bytecode
                </button>

                {compiledMasm && (
                  <div className="panel-block__preview">
                    <label className="field-label">Generated MASM</label>
                    <pre className="code-preview code-preview--masm">{compiledMasm}</pre>
                  </div>
                )}
              </div>
            )}

            {activeTab === 'modules' && (
              <div className="panel-block" role="tabpanel" id="panel-modules" aria-labelledby="tab-modules">
                <h3 className="panel-heading">Robot Modules</h3>
                <div className="module-grid">
                  {modules.map((module, idx) => (
                    <div key={idx} className="module-card" data-testid={`module-${module.port}`}>
                      <div className="module-card__header">
                        <h4>{module.port}</h4>
                        <span className="module-card__badge">{module.type}</span>
                      </div>
                      <div className="module-card__commands">
                        {module.commands.map((cmd, cmdIdx) => (
                          <span key={cmdIdx} className="module-card__chip">
                            {cmd}
                          </span>
                        ))}
                      </div>
                    </div>
                  ))}
                </div>
                <div className="callout callout--info">
                  <p>
                    <strong>Usage:</strong> In MazeScript call methods like{' '}
                    <code>port_1.FORWARD()</code>. In MASM reference data entries with{' '}
                    <code>LOAD_CONST @0</code> where the number targets the data table.
                  </p>
                </div>
              </div>
            )}
          </div>

          {errors.length > 0 && (
            <div className="callout callout--error" role="alert">
              <h4>Compilation Errors</h4>
              <ul>
                {errors.map((error, idx) => (
                  <li key={idx}>{error}</li>
                ))}
              </ul>
            </div>
          )}

          {bytecode.length > 0 && errors.length === 0 && (
            <div className="output-grid">
              {dataTable.length > 0 && (
                <div className="output-card" data-testid="data-table-card">
                  <div className="output-card__header">
                    <h3>Data Table</h3>
                    <span className="output-card__meta">{dataTable.length} entries</span>
                  </div>
                  <div className="data-table-wrapper">
                    <table className="data-table" data-testid="data-table">
                      <thead>
                        <tr>
                          <th>Index</th>
                          <th>Label</th>
                          <th>Type</th>
                          <th>Value</th>
                        </tr>
                      </thead>
                      <tbody>
                        {dataTable.map((entry, idx) => {
                          const labelName = Object.keys(dataLabels).find(
                            (label) => dataLabels[label] === idx && !label.startsWith('@'),
                          );

                          return (
                            <tr key={idx}>
                              <td>{idx}</td>
                              <td>{labelName || 'â€”'}</td>
                              <td>{typeof entry === 'string' ? 'string' : 'number'}</td>
                              <td>{typeof entry === 'string' ? `"${entry}"` : entry}</td>
                            </tr>
                          );
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )}

              <div className="output-card" data-testid="bytecode-section">
                <div className="output-card__header">
                  <div>
                    <h3>Generated Bytecode</h3>
                    <p>{bytecode.length} instructions</p>
                  </div>
                  <button
                    type="button"
                    onClick={exportBinary}
                    className="secondary-button"
                    disabled={bytecode.length === 0 || errors.length > 0}
                  >
                    <FileCode className="secondary-button__icon" aria-hidden="true" />
                    Export Binary (.mzb)
                  </button>
                </div>
                <pre className="code-preview code-preview--bytecode">{formatBytecode()}</pre>
              </div>
            </div>
          )}
        </section>

        <aside className="info-column">
          <div className="info-card glass-panel">
            <div className="info-card__header">
              <LayoutDashboard className="info-card__icon" aria-hidden="true" />
              <div>
                <h3>Build Snapshot</h3>
                <p>Instant visibility into the program you are composing.</p>
              </div>
            </div>
            <div className="stats-grid">
              {statCards.map((card) => (
                <div key={card.label} className="stat-card">
                  <span className="stat-card__label">{card.label}</span>
                  <span className="stat-card__value">{card.value}</span>
                  <span className="stat-card__hint">{card.hint}</span>
                </div>
              ))}
            </div>
            <div className={`status-pill status-pill--${compileStatus.tone}`}>
              <span>{compileStatus.label}</span>
            </div>
            <p className="info-card__footer">{compileStatus.description}</p>
          </div>

          <div className="info-card glass-panel">
            <div className="info-card__header">
              <ScrollText className="info-card__icon" aria-hidden="true" />
              <div>
                <h3>Quick Reference</h3>
                <p>Keep these opcodes and patterns handy while you iterate.</p>
              </div>
            </div>
            <div className="info-card__body">
              <h4>MASM Opcodes</h4>
              <ul className="checklist">
                <li>LOAD_CONST Â· LOAD_VAR Â· STORE_VAR</li>
                <li>ADD Â· SUB Â· MUL Â· DIV Â· MOD</li>
                <li>EQ Â· NEQ Â· LT Â· LTE Â· GT Â· GTE</li>
                <li>AND Â· OR Â· NOT Â· JUMP Â· JUMPT Â· JUMPF</li>
                <li>CALL Â· CALL_METHOD Â· RETURN</li>
                <li>NEW_LIST Â· NEW_OBJECT Â· GET_FIELD Â· SET_FIELD</li>
              </ul>

              <h4>MazeScript Features</h4>
              <ul className="checklist">
                <li>Variables with local scope</li>
                <li>Functions and reusable behaviours</li>
                <li>Conditionals, loops, and method calls</li>
                <li>Table/object and list literals</li>
              </ul>

              <div className="callout callout--subtle">
                <p>
                  <strong>Data Tables:</strong> Store identifiers in the <code>.data</code> section and reference them using{' '}
                  <code>@label</code> or numeric indices such as <code>@0</code>.
                </p>
                <p>
                  <strong>Export:</strong> The exported <code>.mzb</code> file packs bytecode and data entries ready for your robot runtime.
                </p>
              </div>
            </div>
          </div>
        </aside>
      </main>
    </div>
  );
};

export default MazeCompiler;